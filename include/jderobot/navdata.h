//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.3
//
// <auto-generated>
//
// Generated from file `navdata.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __jderobot_navdata_h__
#define __jderobot_navdata_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace jderobot
{

class NavdataData;
class Navdata;
class NavdataPrx;

}

namespace jderobot
{

using arrayInt = ::std::vector<int>;

using arrayFloat = ::std::vector<float>;

}

namespace jderobot
{

class Navdata : public virtual ::Ice::Object
{
public:

    using ProxyType = NavdataPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<NavdataData> getNavdata(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavdata(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace jderobot
{

class NavdataData : public ::Ice::ValueHelper<NavdataData, ::Ice::Value>
{
public:

    virtual ~NavdataData();

    NavdataData() = default;

    NavdataData(const NavdataData&) = default;
    NavdataData(NavdataData&&) = default;
    NavdataData& operator=(const NavdataData&) = default;
    NavdataData& operator=(NavdataData&&) = default;

    /**
     * One-shot constructor to initialize all data members.
     */
    NavdataData(int vehicle, int state, float batteryPercent, int magX, int magY, int magZ, int pressure, int temp, float windSpeed, float windAngle, float windCompAngle, float rotX, float rotY, float rotZ, int altd, float vx, float vy, float vz, float ax, float ay, float az, int tagsCount, const ::jderobot::arrayInt& tagsType, const ::jderobot::arrayInt& tagsXc, const ::jderobot::arrayInt& tagsYc, const ::jderobot::arrayInt& tagsWidth, const ::jderobot::arrayInt& tagsHeight, const ::jderobot::arrayFloat& tagsOrientation, const ::jderobot::arrayFloat& tagsDistance, float tm) :
        vehicle(vehicle),
        state(state),
        batteryPercent(batteryPercent),
        magX(magX),
        magY(magY),
        magZ(magZ),
        pressure(pressure),
        temp(temp),
        windSpeed(windSpeed),
        windAngle(windAngle),
        windCompAngle(windCompAngle),
        rotX(rotX),
        rotY(rotY),
        rotZ(rotZ),
        altd(altd),
        vx(vx),
        vy(vy),
        vz(vz),
        ax(ax),
        ay(ay),
        az(az),
        tagsCount(tagsCount),
        tagsType(::std::move(tagsType)),
        tagsXc(::std::move(tagsXc)),
        tagsYc(::std::move(tagsYc)),
        tagsWidth(::std::move(tagsWidth)),
        tagsHeight(::std::move(tagsHeight)),
        tagsOrientation(::std::move(tagsOrientation)),
        tagsDistance(::std::move(tagsDistance)),
        tm(tm)
    {
    }

    /**
     * Obtains a tuple containing all of the value's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const int&, const float&, const int&, const int&, const int&, const int&, const int&, const float&, const float&, const float&, const float&, const float&, const float&, const int&, const float&, const float&, const float&, const float&, const float&, const float&, const int&, const ::jderobot::arrayInt&, const ::jderobot::arrayInt&, const ::jderobot::arrayInt&, const ::jderobot::arrayInt&, const ::jderobot::arrayInt&, const ::jderobot::arrayFloat&, const ::jderobot::arrayFloat&, const float&> ice_tuple() const
    {
        return std::tie(vehicle, state, batteryPercent, magX, magY, magZ, pressure, temp, windSpeed, windAngle, windCompAngle, rotX, rotY, rotZ, altd, vx, vy, vz, ax, ay, az, tagsCount, tagsType, tagsXc, tagsYc, tagsWidth, tagsHeight, tagsOrientation, tagsDistance, tm);
    }

    /**
     * Obtains the Slice type ID of this value.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    int vehicle;
    int state;
    float batteryPercent;
    int magX;
    int magY;
    int magZ;
    int pressure;
    int temp;
    float windSpeed;
    float windAngle;
    float windCompAngle;
    float rotX;
    float rotY;
    float rotZ;
    int altd;
    float vx;
    float vy;
    float vz;
    float ax;
    float ay;
    float az;
    int tagsCount;
    ::jderobot::arrayInt tagsType;
    ::jderobot::arrayInt tagsXc;
    ::jderobot::arrayInt tagsYc;
    ::jderobot::arrayInt tagsWidth;
    ::jderobot::arrayInt tagsHeight;
    ::jderobot::arrayFloat tagsOrientation;
    ::jderobot::arrayFloat tagsDistance;
    float tm;
};

/// \cond INTERNAL
static NavdataData _iceS_NavdataData_init;
/// \endcond

}

namespace jderobot
{

class NavdataPrx : public virtual ::Ice::Proxy<NavdataPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<NavdataData> getNavdata(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::jderobot::NavdataData>>(true, this, &NavdataPrx::_iceI_getNavdata, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNavdataAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::jderobot::NavdataData>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::jderobot::NavdataData>, P>(false, this, &NavdataPrx::_iceI_getNavdata, context);
    }

    ::std::function<void()>
    getNavdataAsync(::std::function<void(::std::shared_ptr<::jderobot::NavdataData>)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::jderobot::NavdataData>>(response, ex, sent, this, &jderobot::NavdataPrx::_iceI_getNavdata, context);
    }

    /// \cond INTERNAL
    void _iceI_getNavdata(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::jderobot::NavdataData>>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    NavdataPrx() = default;
    friend ::std::shared_ptr<NavdataPrx> IceInternal::createProxy<NavdataPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamReader<::jderobot::NavdataData, S>
{
    static void read(S* istr, ::jderobot::NavdataData& v)
    {
        istr->readAll(v.vehicle, v.state, v.batteryPercent, v.magX, v.magY, v.magZ, v.pressure, v.temp, v.windSpeed, v.windAngle, v.windCompAngle, v.rotX, v.rotY, v.rotZ, v.altd, v.vx, v.vy, v.vz, v.ax, v.ay, v.az, v.tagsCount, v.tagsType, v.tagsXc, v.tagsYc, v.tagsWidth, v.tagsHeight, v.tagsOrientation, v.tagsDistance, v.tm);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace jderobot
{

using NavdataDataPtr = ::std::shared_ptr<NavdataData>;

using NavdataPtr = ::std::shared_ptr<Navdata>;
using NavdataPrxPtr = ::std::shared_ptr<NavdataPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace jderobot
{

class NavdataData;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< NavdataData>&);
::IceProxy::Ice::Object* upCast(NavdataData*);
/// \endcond

class Navdata;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Navdata>&);
::IceProxy::Ice::Object* upCast(Navdata*);
/// \endcond

}

}

namespace jderobot
{

class NavdataData;
/// \cond INTERNAL
::Ice::Object* upCast(NavdataData*);
/// \endcond
typedef ::IceInternal::Handle< NavdataData> NavdataDataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::jderobot::NavdataData> NavdataDataPrx;
typedef NavdataDataPrx NavdataDataPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(NavdataDataPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Navdata;
/// \cond INTERNAL
::Ice::Object* upCast(Navdata*);
/// \endcond
typedef ::IceInternal::Handle< Navdata> NavdataPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::jderobot::Navdata> NavdataPrx;
typedef NavdataPrx NavdataPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(NavdataPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace jderobot
{

typedef ::std::vector< ::Ice::Int> arrayInt;

typedef ::std::vector< ::Ice::Float> arrayFloat;

}

namespace jderobot
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::jderobot::Navdata::begin_getNavdata.
 * Create a wrapper instance by calling ::jderobot::newCallback_Navdata_getNavdata.
 */
class Callback_Navdata_getNavdata_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Navdata_getNavdata_Base> Callback_Navdata_getNavdataPtr;

}

namespace IceProxy
{

namespace jderobot
{

class NavdataData : public virtual ::Ice::Proxy<NavdataData, ::IceProxy::Ice::Object>
{
public:

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Navdata : public virtual ::Ice::Proxy<Navdata, ::IceProxy::Ice::Object>
{
public:

    ::jderobot::NavdataDataPtr getNavdata(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getNavdata(_iceI_begin_getNavdata(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getNavdata(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getNavdata(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNavdata(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavdata(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavdata(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavdata(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavdata(const ::jderobot::Callback_Navdata_getNavdataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavdata(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getNavdata(const ::Ice::Context& context, const ::jderobot::Callback_Navdata_getNavdataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getNavdata(context, cb, cookie);
    }

    ::jderobot::NavdataDataPtr end_getNavdata(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getNavdata(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace jderobot
{

class NavdataData : public virtual ::Ice::Object
{
public:

    typedef NavdataDataPrx ProxyType;
    typedef NavdataDataPtr PointerType;

    virtual ~NavdataData();

    NavdataData()
    {
    }

    /**
     * One-shot constructor to initialize all data members.
     */
    NavdataData(::Ice::Int vehicle, ::Ice::Int state, ::Ice::Float batteryPercent, ::Ice::Int magX, ::Ice::Int magY, ::Ice::Int magZ, ::Ice::Int pressure, ::Ice::Int temp, ::Ice::Float windSpeed, ::Ice::Float windAngle, ::Ice::Float windCompAngle, ::Ice::Float rotX, ::Ice::Float rotY, ::Ice::Float rotZ, ::Ice::Int altd, ::Ice::Float vx, ::Ice::Float vy, ::Ice::Float vz, ::Ice::Float ax, ::Ice::Float ay, ::Ice::Float az, ::Ice::Int tagsCount, const ::jderobot::arrayInt& tagsType, const ::jderobot::arrayInt& tagsXc, const ::jderobot::arrayInt& tagsYc, const ::jderobot::arrayInt& tagsWidth, const ::jderobot::arrayInt& tagsHeight, const ::jderobot::arrayFloat& tagsOrientation, const ::jderobot::arrayFloat& tagsDistance, ::Ice::Float tm) :
        vehicle(vehicle),
        state(state),
        batteryPercent(batteryPercent),
        magX(magX),
        magY(magY),
        magZ(magZ),
        pressure(pressure),
        temp(temp),
        windSpeed(windSpeed),
        windAngle(windAngle),
        windCompAngle(windCompAngle),
        rotX(rotX),
        rotY(rotY),
        rotZ(rotZ),
        altd(altd),
        vx(vx),
        vy(vy),
        vz(vz),
        ax(ax),
        ay(ay),
        az(az),
        tagsCount(tagsCount),
        tagsType(tagsType),
        tagsXc(tagsXc),
        tagsYc(tagsYc),
        tagsWidth(tagsWidth),
        tagsHeight(tagsHeight),
        tagsOrientation(tagsOrientation),
        tagsDistance(tagsDistance),
        tm(tm)
    {
    }

    /**
     * Polymporphically clones this object.
     * @return A shallow copy of this object.
     */
    virtual ::Ice::ObjectPtr ice_clone() const;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    /**
     * Obtains a value factory that instantiates this class.
     * @return The value factory.
     */
    static ::Ice::ValueFactoryPtr ice_factory();

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond

public:

    ::Ice::Int vehicle;
    ::Ice::Int state;
    ::Ice::Float batteryPercent;
    ::Ice::Int magX;
    ::Ice::Int magY;
    ::Ice::Int magZ;
    ::Ice::Int pressure;
    ::Ice::Int temp;
    ::Ice::Float windSpeed;
    ::Ice::Float windAngle;
    ::Ice::Float windCompAngle;
    ::Ice::Float rotX;
    ::Ice::Float rotY;
    ::Ice::Float rotZ;
    ::Ice::Int altd;
    ::Ice::Float vx;
    ::Ice::Float vy;
    ::Ice::Float vz;
    ::Ice::Float ax;
    ::Ice::Float ay;
    ::Ice::Float az;
    ::Ice::Int tagsCount;
    ::jderobot::arrayInt tagsType;
    ::jderobot::arrayInt tagsXc;
    ::jderobot::arrayInt tagsYc;
    ::jderobot::arrayInt tagsWidth;
    ::jderobot::arrayInt tagsHeight;
    ::jderobot::arrayFloat tagsOrientation;
    ::jderobot::arrayFloat tagsDistance;
    ::Ice::Float tm;
};
/// \cond INTERNAL
static ::Ice::ValueFactoryPtr _iceS_NavdataData_init = ::jderobot::NavdataData::ice_factory();
/// \endcond

/// \cond INTERNAL
inline bool operator==(const NavdataData& lhs, const NavdataData& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const NavdataData& lhs, const NavdataData& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Navdata : public virtual ::Ice::Object
{
public:

    typedef NavdataPrx ProxyType;
    typedef NavdataPtr PointerType;

    virtual ~Navdata();

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual NavdataDataPtr getNavdata(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getNavdata(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Navdata& lhs, const Navdata& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Navdata& lhs, const Navdata& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<typename S>
struct StreamWriter< ::jderobot::NavdataData, S>
{
    static void write(S* ostr, const ::jderobot::NavdataData& v)
    {
        ostr->write(v.vehicle);
        ostr->write(v.state);
        ostr->write(v.batteryPercent);
        ostr->write(v.magX);
        ostr->write(v.magY);
        ostr->write(v.magZ);
        ostr->write(v.pressure);
        ostr->write(v.temp);
        ostr->write(v.windSpeed);
        ostr->write(v.windAngle);
        ostr->write(v.windCompAngle);
        ostr->write(v.rotX);
        ostr->write(v.rotY);
        ostr->write(v.rotZ);
        ostr->write(v.altd);
        ostr->write(v.vx);
        ostr->write(v.vy);
        ostr->write(v.vz);
        ostr->write(v.ax);
        ostr->write(v.ay);
        ostr->write(v.az);
        ostr->write(v.tagsCount);
        ostr->write(v.tagsType);
        ostr->write(v.tagsXc);
        ostr->write(v.tagsYc);
        ostr->write(v.tagsWidth);
        ostr->write(v.tagsHeight);
        ostr->write(v.tagsOrientation);
        ostr->write(v.tagsDistance);
        ostr->write(v.tm);
    }
};

template<typename S>
struct StreamReader< ::jderobot::NavdataData, S>
{
    static void read(S* istr, ::jderobot::NavdataData& v)
    {
        istr->read(v.vehicle);
        istr->read(v.state);
        istr->read(v.batteryPercent);
        istr->read(v.magX);
        istr->read(v.magY);
        istr->read(v.magZ);
        istr->read(v.pressure);
        istr->read(v.temp);
        istr->read(v.windSpeed);
        istr->read(v.windAngle);
        istr->read(v.windCompAngle);
        istr->read(v.rotX);
        istr->read(v.rotY);
        istr->read(v.rotZ);
        istr->read(v.altd);
        istr->read(v.vx);
        istr->read(v.vy);
        istr->read(v.vz);
        istr->read(v.ax);
        istr->read(v.ay);
        istr->read(v.az);
        istr->read(v.tagsCount);
        istr->read(v.tagsType);
        istr->read(v.tagsXc);
        istr->read(v.tagsYc);
        istr->read(v.tagsWidth);
        istr->read(v.tagsHeight);
        istr->read(v.tagsOrientation);
        istr->read(v.tagsDistance);
        istr->read(v.tm);
    }
};

}
/// \endcond

namespace jderobot
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::jderobot::Navdata::begin_getNavdata.
 * Create a wrapper instance by calling ::jderobot::newCallback_Navdata_getNavdata.
 */
template<class T>
class CallbackNC_Navdata_getNavdata : public Callback_Navdata_getNavdata_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const NavdataDataPtr&);

    CallbackNC_Navdata_getNavdata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        NavdataPrx proxy = NavdataPrx::uncheckedCast(result->getProxy());
        NavdataDataPtr ret;
        try
        {
            ret = proxy->end_getNavdata(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::jderobot::Navdata::begin_getNavdata.
 */
template<class T> Callback_Navdata_getNavdataPtr
newCallback_Navdata_getNavdata(const IceUtil::Handle<T>& instance, void (T::*cb)(const NavdataDataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Navdata_getNavdata<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::jderobot::Navdata::begin_getNavdata.
 */
template<class T> Callback_Navdata_getNavdataPtr
newCallback_Navdata_getNavdata(T* instance, void (T::*cb)(const NavdataDataPtr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Navdata_getNavdata<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::jderobot::Navdata::begin_getNavdata.
 * Create a wrapper instance by calling ::jderobot::newCallback_Navdata_getNavdata.
 */
template<class T, typename CT>
class Callback_Navdata_getNavdata : public Callback_Navdata_getNavdata_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const NavdataDataPtr&, const CT&);

    Callback_Navdata_getNavdata(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        NavdataPrx proxy = NavdataPrx::uncheckedCast(result->getProxy());
        NavdataDataPtr ret;
        try
        {
            ret = proxy->end_getNavdata(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::jderobot::Navdata::begin_getNavdata.
 */
template<class T, typename CT> Callback_Navdata_getNavdataPtr
newCallback_Navdata_getNavdata(const IceUtil::Handle<T>& instance, void (T::*cb)(const NavdataDataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Navdata_getNavdata<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::jderobot::Navdata::begin_getNavdata.
 */
template<class T, typename CT> Callback_Navdata_getNavdataPtr
newCallback_Navdata_getNavdata(T* instance, void (T::*cb)(const NavdataDataPtr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Navdata_getNavdata<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
